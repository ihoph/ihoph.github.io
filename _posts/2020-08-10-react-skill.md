---
layout: post
title:  리액트를 다루는 기술 정리
date:   2020-08-10 19:00:00 +0800
categories: 책/강의
tag: 리액트
sitemap :
  changefreq : daily
  priority : 1.0
---

이 포스트에서는 velopert님의 [리액트를 다루는 기술](https://book.naver.com/bookdb/book_detail.nhn?bid=15372757)을 정리합니다. 정리하는대로 조금씩 업데이트할 예정입니다.

## 1. 리액트 시작

### 1.1 왜 리액트인가?

웹 페이지에서 업데이트하는 항목에 따라 어떤 부분을 찾아서 변경할지 규칙을 정하는 작업은 간단하지만, 애플리케이션 규모가 크면 상당히 복잡해지고 제대로 관리하지 않으면 성능도 떨어질 수 있다. 이를 개선하기 위해 어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 것이 아니라 기존 뷰를 날려버리고 처음부터 새로 렌덩하는 방식을 생각할 수 있다. 리액트가 이러한 것을 해준다.

### 1.2 리액트 이해

리액트는 오직 뷰만 신경쓰는 라이브러리다. 리액트는 초기 렌더링, 조화 과정을 거친다. 

초기 렌더링

초기 렌더링에서 render 함수는 컴포넌트(특정 부분이 어떻게 생길지 정하는 선언체)가 어떻게 생겼는지 정의하는 역할을 한다. render 함수는 html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환한다. 컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈 수 있다. 이 때 render 함수를 실행하면 그 내부에 있는 컴포넌트들도 재귀적으로 렌더링한다. 최상위 컴포넌트의 렌더링 작업이 끝나면 니니고 있는 작업들을 사용하여 html 마크업을 만들고, 이룰 우리가 정하는 실제 페이지의 dom 요소 안에 주입한다.

조화 과정

컴포넌트에서 데이터에 변화가 있을 때 우리가 보기에는 변화에 따라 뷰가 변형되는 것처럼 보이지만 사실 새로운 요소로 갈아끼운다. 컴포넌트는 데이터를 업데이트했을 때 단순히 업데이트한 값을 수정하는 것이 아니라, 새로운 데이터를 가지고 render 함수를 또 다시 호출한다. 그러면 render 함수는 그 데이터를 지닌 뷰를 생성한다. 이 때 render 함수가 반환하는 결과를 곧바로 dom에 반영하지 않고, 이전 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보를 비교한다. 비교 후  둘의 차이를 알아내 최소한의 연산으로 dom 트리를 업데이트한다. 즉, 루트 노드부터 시작하여 전체 컴포넌트를 처음부터 다시 렌더링하는 것처럼 보이지만, 사실 최적의 자원을 사용하여 이를 수행하는 것이다.

### 1.3 리액트의 특징

dom은 객체로 문서 구조를 표현하는 방법이다. dom은 약점이 있는데, 동적 ui에 최적화되어 있지 않다는 것이다. 규모가 큰 웹 애플리케이션에서 dom에 직접 접근하여 변화를 주다 보면 성능이슈가 조금씩 발생한다. dom 자체가 느린 것은 아니다. 단, 웹 브라우저 단에서 dom에 변화가 일어나면 웹 브라우저가 css를 다시 연산하고, 레이아웃으 ㄹ 구성하고, 페이지를 리페인트하게 되는데 이 과정에서 시간을 허비한다. 이를 해결하기 위해서는 dom을 최소한으로 조작하여 작업을 처리해야 한다. 리액트는 virtual dom 방식을 사용하여 dom 업데이트를 추상화함으로써 dom 처리 횟수를 최소화하고 효율적으로 진행한다.

virtual dom을 사용하면 실제 dom에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용한다. 리액트에서 데이터가 변하여 웹 브라우저에 실제 dom을 업데이트할 때는 다음 세 절차를 거친다.

1. 데이터를 업데이트하면 전체 ui를 virtual dom에 리렌더링한다.
2. 이전 virtual dom에 있던 내용과 현재 내용을 비교한다.
3. 바뀐 부분만 실제 dom에 적용한다.

## 2. JSX

프로젝트 생성 과정에서 node_modlues 디렉터리에 react 모듈이 설치된다. 그리고 import를 통해 리액트를 불러온다. 이렇게 모듈을 불러와 사용하는 것은 사실 원래 브라우저에는 없던 기능이다. 브라우저가 아닌 환경에서 자바스크립트를 실행할 수 있게 해주는 환경인 Node.js에서 지원하는 기능이다. 이러한 기능을 브라우저에서도 사용하기 위해 번들러를 사용한다. 번들은 묶는다는 뜻이고, 즉 파일을 묶듯이 연결하는 것이다. 대표적은 번들러로 웹팩이 있다. 번들러를 사용하면 import로 모듈을 불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해준다. 또 최적화 과정에서 여러 개의 파일로 분리될 수도 있다. 웹팩을 사용하면 svg파일과 css파일도 불러와 사용할 수 있는데, 이렇게 파일들을 불러오는 것은 웹팩의 로더라는 기능이 담당한다. 

> **최신 자바스크립트로 작성된 코드를 변환하는 이유**
>
> ES5는 이전 버전의 자바스크립트를 의미한다. 최신 자바스크립트 문법을 ES5 형태로 변환하는 것은 구버전 웹 브 라우저와 호환하기 위해서다. JSX도 정식 자바스크립트 문법이 아니므로 ES5 형태의 코드로 변환해야 한다.

### 2.1 JSX란?

JSX로 작성된 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환된다. JSX를 사용하면 편하게 UI를 렌더링할 수 있다.

> **ES6의 const와 let**
>
> var는 scope가 함수 단위다. 이를 개선하는 것이 let과 const이다. let과 const는 scope가 함수 단위가 아니라 블록 단위이다. ES6에서 var을 사용할 일은 없다. let은 한번 선언한 후 값이 유동적으로 변할 수 있을 때만(예: for문) 사용하고, const는 한번 설정한 후 변할 일이 없는 값에 사용한다. 편하게 기본적으로 const, 해당 값을 바꿔야 할 때는 let을 사용한다.

## 3. 컴포넌트

컴포넌트의 기능은 단순한 템플릿 이상이다. 데이터가 주어졌을 때 이에 맞춰 ui를 만들어주는 것은 물론이고, 라이프사이클 api를 사용하여 컴포넌트가 화면에서 나타날 때, 사라질 때, 변화가 일어날 때 주어진 작업들을 처리할 수 있으며, 임의 메서드를 만들어 특별한 기능을 붙여줄 수 있다.

컴포넌트를 선언하는 방식은 두가지다. 하나는 함수형 컴포넌트고, 또 다른 하나는 클래스형 컴포넌트다. 클래스형 컴포넌트와 함수형 컴포넌트의 차이점은 클래스형 컴포넌트의 경우 이후 배울 state 기능 및 라이프사이클 기능을 상요할 수 있다는 것과 임의 메서드를 정의할 수 있다는 것이다. 클래스형 컴포넌트에서는 render 함수가 꼭 있어야 하고, 그 안에서 보여주어야 할 jsx를 반환해야 한다. 

함수형 컴포넌트의 장점을 나열해보면 다음과 같다. 우선 클래스형 컴포넌트보다 선언하기 훨씬 편하다. 메모리 자원도 클래스형 컴포넌트보다 덜 사용한다. 또한 프로젝트를 완성하여 빌드한 후 배포할 때도 함수형 컴포넌트를 사용하는 것이 결과물의 크기가 더 작다. 함수형 컴포넌트의 주요 단점은 state와 라이프사이클 api의 사용이 불가능하다는 점이다. 이 단점은 hooks라는 기능이 도입되면서 해결되었다.

function()과 () => 는 서로 가리키는 this가 다르다. 일반 함수는 자신이 종속된 객체를 this로 가리키고, 화살표 함수는 자신이 종속된 인스턴스를 가리킨다. 

export는 다른 파일에서 파일을 import할 때 선언한 클래스를 불러오도록 한다.

**props**

props는 properties를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용되는 요소다. props 값은 부모 컴포넌트에서 설정할 수 있다. defaultProps를 설정하면 props의 기본값을 설정할 수 있다.

children을 사용하면 태그 사이의 내용을 보여줄 수 있다.

컴포넌트의 필수 props를 지정하거나 props의 타입을 지정할 땐 propTypes를 사용한다. isRequired를 사용하면 필수 propTypes를 설정할 수 있다.

**state**

리액트에서 state는 컴포넌트 내부에서 바뀔 수 있는 값을 의미한다. props는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽기 전용으로만 사용할 수 있다. props를 바꾸려면 부모 컴포넌트에서 바꾸어 주어야 한다. 리액트에는 두 종류의 state가 있다. 하나는 클래스형 컴포넌트가 지니고 있는 state이고 다른 하나는 함수형 컴포넌트에서 useState라는 함수를 통해 사용하는 state이다.

클래스형 컴포넌트든 함수형 컴포넌트든 state를 사용할 때는 주의해야 할 사항이 있다. state 값을 바꿔야 할 때는 setState 혹은 useState를 통해 전달받은 세터 함수를 사용해야 한다.

props와 states는 둘 다 컴포넌트에서 사용하거나 렌더링할 데이터를 담고 있으므로 비슷해 보일 수 있지만, 그 역할은 다르다. props는 부모 컴포넌트가 설정하고, state는 컴포넌트 자체적으로 지닌 값으로 컴포넌트 내부에서 값을 업데이트할 수 있다.