---
layout: post
title:  스프링 마이크로서비스 코딩 공작소 정리
date:   2020-09-02 19:01:00 +0800
categories: 책/강의
tag: msa
sitemap :
  changefreq : daily
  priority : 1.0
---

## 1. 스프링, 클라우드와 만나다.

### 1.1 마이크로 서비스란?

마이크로서비스 개념이 발전하기 전, 대부분의 웹 기반 애플리케이션은 모놀리식 아키텍처 형태로 개발되었다. 모놀리식 아키텍처에서 애플리케이션은 배포 가능한 단일 소프트웨어 산출물로 전달된다. UI 및 비즈니스 로직, 데이터베이스 액세스 로직 모두가 하나의 애플리케이션 산출물로 패키징되고 애플리케이션 서버에 배포되는 것이다.

애플리케이션은 단일 작업 단위로도 배포할 수 있지만, 실제로는 여러 개발 팀이 한 애플리케이션에서 작업할 때가 더 많다. 일반적으로 각 개발 팀은 특정 고객에게 제공하는 애플리케이션의 개별 기능을 담당한다. 필자의 경험상 여러 팀과 관련된 애플리케이션이 있었다고 한다. 각 팀에는 요구 사항과 출시 요구 사항에 대한 고유 책임 영역이 있고, 모든 작업은 단일 코드 베이스에 동기화된다. 여기서 문제는 모놀리식 애플리케이션이 크고 복잡해지면 애플리케이션을 담당하는 각 팀의 의사 소통과 조정 비용이 증가한다는 것이다. 모놀리식 애플리케이션은 각 팀에서 변경이 있을 때마다 애플리케이션 전체를 다시 빌드하고 테스트해서 배포해야 한다.

마이크로서비스 개념은 대형 모놀리식 애플리케이션을 기술 및 조직적으로 확장하려고 할 때 생기는 많은 난제에 대한 직접적 대안이 됐다. 마이크로서비스는 느슨히 결합된 작은 분산 서비스이다. 마이크로서비스를 사용하면 대형 애플리케이션을 관리하기 쉽고, 제한된 책임을 담당하는 컴포넌트로 분해할 수 있다. 마이크로서비스는 코드 베이스를 명확히 정의한 작은 조각으로 분리해서 대형 코드 베이스에서 발생하는 전통적인 복잡성 문제를 해결한다. 마이크로서비스를 고려할 때 수용해야 할 핵심 개념은 애플리케이션 기능을 분해하고 분리해서 완전히 상호 독립적이어야 한다는 것이다.

책의 그림을 보면 각 팀이 서비스 코드와 서비스 인프라스트럭처를 완전히 소유하고 있음을 알 수 있다. 코드와 소스 관리 저장소, 인프라스트럭처가 이제 애플리케이션의 다른 부분과 완전히 독립적이기 대문에 각 팀은 독립적으로 빌드와 테스트, 배포를 할 수 있다.

마이크로서비스 아키텍처의 특징은 다음과 같다.

1. 애플리케이션 로직을 각자 책임이 명확한 작은 컴포넌트들로 분해하고 이들을 조합해서 솔루션을 제공한다.
2. 각 컴포넌트는 작은 책임 영역을 담ㄷ낭하고 완전히 상호 독립적으로 배포된다. 마이크로서비스는 비즈니스 영역으 ㅣ 한 부분에서만 책임을 담당한다. 그리고 여러 애플리케이션에서 재사용할 수 있어야 한다.
3. 마이크로서비스는 몇 가지 기본 원칙에 기반을 두며, 서비스 소비자와 서비스 제공자 사이의 데이터 교환을 위해 HTTP와 JSON같은 경량 통신 프로토콜을 사용한다.
4. 애플리케이션은 항상 기술 중립적 프로토콜(JSON이 보편적)을 사용해 통신하므로 서비스 구현 기술과는 무관하다.
5. 작고 독립적이며 분산된 마이크로서비스를 사용해 조직은 명확히 정의된 책임 영역을 담당하는 소규모 팀을 보유할 수 있다.

### 1.2 스프링은 마이크로서비스와 어떤 관련이 있을까?

스프링 프레임워크는 J2EE 스택으로 애플리케이션을 구축하는 방법을 찾고 있는 엔터프라이즈 자바 애플리케이션 개발자에게 더 가벼운 대안으로 빠르게 자리 잡았다. 많은 사람이 J2EE를 강력하지만 개발팀이 상요하지 않는 기능이 많이 포함된 블로트웨어(쓸데없이 메모리를 많이 잡아먹음)로 간주했다. 게다가 J2EE 애플리케이션을 사용하면 모든 특성을 갖춘 (그래서 무거운) 자바 애플리케이션 서버로 애플리케이션을 배포해야 했다.

스프링 개발 팀은 많은 개발 팀이 애플리케이션의 프레젠테이션과 비즈니스, 데이터 액세스 로직을 함께 패키징하고 단일 산출물로 배포하는 모놀리식 애플리케이션에서 이탈하고 있다는 것을 재빨리 파악했다. 그 대신 작고 분산되어 클라우드에 쉽게 배포 가능한 서비스를 구축하려는 고도의 분산 모델로 이동하고 있었다. 이러한 변화에 부응하기 위해 스프링 개발 팀은 스프링 부트와 스프링 클라우드라는 프로젝트를 시작했다.

스프링 부트는 스프링 프레임워크를 재구성한 것이다. 스프링의 핵심 기능은 수용하지만 많은 엔터프라이즈 기능을 제거하고 대신 자바 기반의 REST 지향 마이크로서비스 프레임워크를 제공한다. 단순한 애너테이션으로 자바 개발자는 외부 애플리케이션 컨테이너 없이도 패키지하고 배포할 수 있는 REST 마이크로서비스를 신속하게 구축할 수 있다.

스프링 부트는 일반적인 REST 마이크로서비스의 작업(비즈니스 로직에 경로 설정 및 URL에서 HTTP 매개변수 파싱, JSON 을 자바 객체로 상호 매핑)을 추상화하고 개발자가 서비스 비즈니스 로직에 집중할 수 있게 한다. 스프링 부트가 해주는 일의 순서를 정리해보면 다음과 같다.

1. 클라이언트가 스프링부트 애플리케이션에 HTTP 요청을 보낸다.
2. 경로 매핑: 스프링 부트는 HTTP 요청을 파싱하고 HTTP 동사와 URL, URL에 정의된 매개변수를 기반으로 경로를 매핑한다. 경로는 스프링 RestController 클래스의 메서드에 매핑된다.
3. 매개변수 분해: 스프링 부트가 경로를 인식하면 경로 내부에 정의된 매개변수를 작업을 수행핧 자바 메서드에 매핑한다.
4. JSON -> 자바 객체 매핑: HTTP PUT이나 POST는 HTTP 본문에서 전달된 JSON을 자바 클래스에 매핑한다.
5. 비즈니스 로직 실행: 모든 데이터가 매핑되면 스프링 부트는 비즈니스 로직을 실행한다.
6. 자바 -> JSON 객체 매핑: 비즈니스 로직이 실행되면 스프링 부트는 자바 객체를 JSON으로 변환한다.
7. 클라이언트는 서비스에서 JSON으로 응답을 받는다. 

마이크로서비스가 클라우드 기반 애플리케이션을 구축하는 일반적인 아키텍처 패턴 중 하나로 발전했기 때문에 스프링 개발 커뮤니티는 우리에게 스프링 클라우드를 선사했다. 스프링 클라우드 프레임워크를 사용하면 사설 및 공용 클라우드에 마이크로서비스를 쉽게 운영하고 배포할 수 있다. 스프링 클라우드는 널리 사용되는 클라우드 관리용 마이크로서비스 프레임워크를 공통 프레임워크에 포함하고, 코드에서 애너테이션을 다는 것처럼 이러한 기술을 쉽게 사용하고 배포할 수 있게 했다.

### 1.3 애플리케이션 구축 방식을 바꾸는 이유

현대 사회는 빠르게 변화하고 있다.

1. 복잡성이 증가했다: 고객은 조직의 모든 부분이 자신을 인식하길 기대한다. 단 하나의 데이터베이스와 통신하고 다른 애플리케이션과 통합하지 않는 단절된 애플리케이션은 더이상 표준이 아니다.
2. 고객은 더 빠른 출시를 원한다: 고객은 더 이상 소프트웨어 패키지를 연 단위로 릴리스하거나 버전을 올리길 기대하지 않는다.
3. 성능 및 확장성: 글로벌 애플리케이션에서는 애플리케이션이 처리해야 할 트랜잭션 양과 유입될 시점을 예측하기 어렵다. 애플리케이션은 여러 서버로 신속히 확장한 후 확장이 필요 없다면 다시 축소해야 한다.
4. 고객은 애플리케이션을 항상 사용할 수 있길 기대한다: 고객은 한 번의 클릭만으로 경쟁사로 이탈할 수 있으므로 회사의 애플리케이션은 회복성이 높아야 한다.

이러한 기대 사항을 충족하려면 확장성과 중복성이 높은 애플리케이션을 구축하기 위해 독립적으로 빌드하고 배포할 수 있는 작은 서비스로 애플리케이션을 분해해야 한다는 역설을 수용해야 한다. 애플리케이션을 작은 서비스로 떼어내서 단일한 모놀리식 산출물에서 벗어난다면 다음 특징이 있는 시스템을 구축할 수 있다.

1. 유연성: 새로운 기능을 신속하게 제공하도록 분리된 서비스를 구성하고 재배치할 수 있다. 다른 것과 동작하는 코드 단위가 작을수록 코드 변경에 따른 복잡성을 낮추고 코드 배포를 테스트하는 시간도 줄어든다.
2. 회복성: 분리된 서비스란 더이상 애플리케이션 한 부분의 저하로 전체가 망가지는 진흙덩이 애플리케이션이 아니라는 의미다. 실패는 애플리케이션의 작은 부분에 국한되어 애플리케이션 전체 장애로 확대되기 전에 억제된다.
3. 확장성: 분리된 서비스를 여러 서버에 수평적으로 쉽게 분산할 수 있어 기능 및 서비스를 적절히 확장할 수 있다. 애플리케이션의 모든 로직이 얽혀 ㅇㅆ는 모놀리식 애플리케이션은 한 부분이 병목점이 되더라도 전체를 확장해야 한다.

이러한 취지에서 마이크로서비스를 논의할 때 다음 사항을 명심하자. 

작고 단순하며 분리된 서비스 = 확장 가능하고 회복적이며 유연한 애플리케이션

### 1.4 클라우드란 정확히 무엇인가?

클라우드 기반 컴퓨팅에는 다음 세 가지 기본 모델이 존재한다. 이 개념을 이해하기 위해 식사를 준비하는 작업 예시를 들어보자.

1. 집에서 직접 해먹는다(집밥).
2. 식료품점에서 냉동 음식을 사 먹는다.
3. 배달 음식을 먹는다.
4. 차를 타고 식당에 가서 먹는다.

선택 사항별 차이는 음식을 요리할 책임자와 요리 장소다. 온프레미스 모델(집밥)을 먹을 때는 집에 있는 오븐과 식재룔르 사용해 직접 모든 일을 해야 한다. 상점에서 구매한 음식은 IAAS 모델과 같다. 상점 요리사와 오븐으로 미리 준비해 놓은 음식을 집에서 데워 먹어야 한다. PaaS 모뎅레서도 여전히 식사에 대한 책임이 있지만 식사의 핵심 업무는 공금자에게 의존한다. 예를 들어 PaaS 모델에서 쩝시와 가구는 여러분이 제공해야 하지만 식당 주인이 오븐과 식재료, 요리사를 지원해 요리를 대신한다. SaaS 모델에서는 식당에 가서 차려진 식사를 하는 것과 같다.

각 모델에서 요점은 통제에 관한 것, 즉 누가 인프라스트 럭처를 유지 보수하고 애플리케이션 구축을 위해 어떤 기술을 사용할지 하는 점이다. IaaS 모델에서 클라우드 공급자는 기본적인 인프라스 트럭처를 제공하지만 기술 선택과 최종 솔루션 구축은 여러분 몫이다. 반면 SaaS 모델에서 여러분은 공급자가 제공하는 서비스의 수동적 소비자이며 기술 선택이나 애플리케이션을 위한 인프라스트럭처를 유지 보수할 책임이 없다.

### 1.5 왜 클라우드와 마이크로서비스인가?

마이크로서비스 기반 아키텍처의 핵심 개념은 각 서비스를 독립된 개별 산출물로 패키징하고 배포한다는 것이다. 서비스 인스턴스를 신속하게 시작할 수 있고 서비스 인스턴스는 서로 차이가 없어야 한다.

마이크로서비스를 작성하는 개발자는 서비스를 다음 중 어디에 배포할지 결저앻야 할 것이다.

1. 물리적 서버
2. 가상 머신 이미지
3. 가상 컨테이너

클라우드에 기반을 둔 마이크로서비스의 장점은 탄력성 개념을 중심으로 한다. 클라우드 서비스 공급자를 통해 몇 분 안에 새로운 가상 머신과 컨테이너를 빠르게 가동시킬 수 있다. 서비스 용량이 감소한다면 추가 비용을 들이지 ㅇ낳고도 가상 서버를 줄일 수 있다. 클라우드 공급자를 사용해 마이크로서비스를 배포하면 애플리케이션을 위해 훨씬 더 높은 수준의 수평 확장성(서버와 서비스 인스턴스 추가)을 얻는다. 서버 탄력성은 애플리케이션 또한 회복력이 높다는 것을 의미한다. 마이크로서비스 중 하나에 문제가 발생해서 고장나더라도 새로운 서비스 인스턴스를 가동해 개발 팀이 문제를 해결할 수 있을 만큼 오랜 기간 애플리케이션을 정상으로 유지할 수 있다.

책에서는 마이크로서비스 관련 인프라스트럭처를 도커 컨테이너를 사용해 IaaS 기반 클라우드 공급자에게 배포한다. 

1. 간소화된 인프라스터럭처 관리
2. 엄청난 수평 확장성
3. 지리적 분산을 이용한 높은 중복성

### 1.6 마이크로서비스는 코드 작성 이상을 의미

견고한 마이크로서비스 애플리케이션을 실행하고 지원하는 것은 꽤 어려운데, 다음과 같은 주제가 있다.

1. 적정 크기
2. 위치 투명성
3. 회복성
4. 반복성
5. 확장성

#### 1.6.1 마이크로서비스 핵심 개발 패턴

마이크로서비스 핵심 개발 패턴은 마이크로서비스 구축에 대한 기본 사항(서비스 세분성, 통신 프로토콜, 인터페이스 설계, 구성 관리, 이벤트 프로세싱 등)을 다룬다.

**1. 마이크로서비스 라우팅 패턴**

마이크로서비스 라우팅 패턴은 마이크로서비스를 사용하려는 클라이언트 애플리케이션 서비스의 위치를 발견하고 라우팅하는 방법을 다룬다. 서비스의 물리적 IP 주소를 추상화하고 서비스 호출에 대한 단일 진입점을 만들어야 모든 서비스 호출에 대한 일관된 보안과 콘텐츠 정책을 보장할 수 있다. 서비스 디스커버리와 라우팅은 "서비스에 대한 클라이언트의 요청을 특정 서비스 인스턴스에 어떻게 전달할 수 있을까?"라는 질문에 대한 답변이다.

**2. 마이크로서비스 클라이언트 회복성 패턴**

마이크로서비스 아키텍처는 고도로 분산되어 있어서 1개의 서비스 문제가 서비스 소비자에게 연쇄적으로 발생하지 않도록 방지해야 한다. 

1. 클라이언트 측 부하 분산
2. 회로 차단기 패턴
3. 폴백 패턴
4. 벌크헤드 패턴

**3. 마이크로서비스 보안 패턴**

**4. 마이크로서비스 로깅 및 추적 패턴**

마이크로서비스의 단점은 애플리케이션과 서비스 안에서 어떤 일이 일어나고 있는지 디버깅과 추적이 훨씬 어렵다는 것이다.

1. 로그 상관관계
2. 로그 수집
3. 마이크로서비스 추적

**5. 마이크로서비스 빌드 및 배포 패턴**

인프라스트럭처 구성을 빌드 배포 프로세스에 통합해 더이상 자바 WAR나 EAR처럼 소프트웨어 산출물을 이미 실행한 인프라스트럭처에 배포하지 않는 것이다. 그 대신 마이크로서비스와 빌드 프로세스 일부로 마이크로서비스가 실행되는 가상 서버 이미지를 빌드하고 컴파일해야 한다. 그 후 마이크로서비스를 배포할 때 서버가 실행될 머신 이미지를 배포할 수 있다.

### 1.7 스프링 클라우드로 마이크로서비스 구축

#### 1.7.1 스프링 클라우드 컨피그

스프링 클라우드 컨피그는 중앙 집중식 서비스로 애플리케이션 구성 데이터 관리를 담당하고 애플리케이션 데이터(특히 환경별 구성 데이터)를 마이크로서비스와 완전히 분리한다. 따라서 마이크로서비스 인스턴스가 아무리 많더라도 항상 동일한 구성을 유지할 수 있다.

#### 1.7.2 스프링 칼루으드 서비스 디스커버리

서비스 디스커버리를 사용하면 서비스를 사용하는 클라이언트에 서버가 배포된 물리적 위치(IP주소나 서버 이름)를 추상화할 수 있다. 서비스 소비자는 물리적 위치보다 논리적 이름을 사용해 서버의 비즈니스 로직을 호출한다.

#### 1.7.3 넷플릭스 히스트릭스와 리본

넷플릭스 히스트릭스 라이브러리를 사용하면 회로 차단기와 벌크헤드 같은 서비스 클라이언트 회복성 패턴을 신속하게 구현할 수 있다. 

#### 1.7.4 넷플릭스 주울

서비스 라우팅 기능을 제공한다.

#### 1.7.5 스프링 클라우드 스트림

마이크로서비스에 경량 메시지 프로세싱을 쉽게 통합할 수 있는 기술이다.

#### 1.7.6 스프링 클라우드 슬루스

애플리케이션 안에서 사용되는 HTTP 호출과 메시지 채널에 고유 추적 식별자를 통합할 수 있다.

#### 1.7.7 스프링 클라우드 시큐리티

서비스에 액세스할 수 있는 사람과 어떤 일을 할 수 있는지 통제할 수 있는 인증 및 인가 프레임워크다. 토큰에 기반을 두며 인증 서버가 발행한 토큰으로 서비스는 서로 통신한다.

#### 1.7.8 프로비저닝

스프링 프레임워크는 애플리케이션 개발에 맞춰져 있고 스프링 클라우드처럼 빌드와 배포 파이프라인을 생성할 수 있는 도구가 없다. Travis CI와 도커를 사용할 것이다.

## 2. 스프링 부트로 마이크로서비스 구축

전통적인 폭포수 개발 방법론은 다음과 같은 단점이 발생했다.

1. 강한 결합: 비즈니스 로직 호출은 SOAP이나 REST 같은 구현 기술에 중립적인 프로토콜 수준이 아닌 프로그래밍 언어 수준에서 이루어진다. 따라서 애플리케이션 컴포넌트를 조금만 수정해도 그 애플리케이션의 다른 부분을 깨뜨리거나 새로운 버그를 생산할 가능성이 높다.
2. 누설: 다른 영역의 데이터에 쉽게 접근하게 되면 보이지 않는 의존성이 생겨나고 컴포넌트의 내부 데이터 구조에 대한 세부 구현이 애플리케이션 전체에 유출될 수 있다. 데이터베이스 테이블 하나를 조금만 변경해도 애플리케이션 전반에 걸쳐 엄청난 코드 수정과 회귀 테스팅이 필요할 수 있다.
3. 모놀리식: 여러 팀에서 공유되는 단일 코드 베이스에 저장하므로 코드를 변경할 때마다 전체 애플리케이션을 재컴파일하고, 전체 테스팅 주기를 재수행하며 재배포한다. 애플리케이션 코드 베이스를 조금만 변경해도 비용이 많이 들며 오랜 시간이 소요된다.

마이크로서비스 기반 아키텍처의 접근법은 다음과 같은 특성을 가진다.

1. 제한: 마이크로서비스는 하나의 책임 집합을 가지며 범위가 좁다.
2. 느슨한 결합: msa 기반 애플리케이션은 작은 서비스 집합이며, HTTP와 REST처럼 비독점적 호출 프로토콜을 사용하는 구현 기술에 중립적인 인터페이스로 서로 소통한다. 서비스에 대한 인터페이스가 변하지 않는 한 마이크로서비스 소유자는 전통적인 애플리케이션 아키텍처보다 서비스를 더 자유롭게 수정할 수 있다.
3. 추상화: 마이크로서비스는 자신의 데이터 구조와 데이터 소스를 완전히 소유한다. 마이크로서비스가 소유한 데이터는 해당 서비스만 수정할 수 있다. 
4. 독립적: 마이크로서비스는 서로 독립적으로 컴파일하고 배포할 수 있다. 이는 상호 의존성이 높은 모놀리식 애플리케이션보다 변경 사항을 훨씬 쉽게 분리하고 테스트할 수 있다는 것을 의미한다.

클라우드에 기반을 둔 개발에 이러한 msa의 특성이 중요한 이유를 알아보자. 클라우드 기반 애플리케이션은 일반적으로 다음 특징이 있다.

1. 사용자 층이 다양하며 대규모다: 고객마다 서로 다른 제품 기능을 원하며, 이 기능을 접하기까지 애플리케이션의 긴 릴리스 주기를 기다리고 싶어 하지 않는다. 마이크로서비스는 작은 범위를 담당하고, 명확히 정의된 인터페이스를 통해 접근하므로 기능을 신속히 제공할 수 있다.
2. 상당한 작동 시간이 요구된다: 마이크로서비스 자체의 분산적 특성 때문에 마이크로서비스 기반 애플리케이션은 애플리케이션 전체를 중단하지 않고도 고장과 문제를 더 쉽게 격리할 수 있다. 이로 인해 전반적인 애플리케이션 작동 중지 시간은 줄어들고 결함 저항력은 높아진다.
3. 볼륨이 균일하지 않다: 기업 환경과 다르게 클라우드 기반 애플리케이션 환경에서는 용량(수요)이 갑자기 늘 수 있다. 마이크로서비스는 독립적인 배포가 가능한 작은 컴포넌트로 분리되어 있기 때문에 부하를 받는 컴포넌트를 조명하고 여러 서버에 수평 확장하기도 쉽다.

성공적인 마이크로서비스 개발 토대는 대개 다음 중요한 세 역할의 관점에서 시작한다.

1. 아키텍트: 솔루션을 제공하기 위해 큰 그림을 바라보고 애플리케이션을 개별 마이크로서비스로 분해하는 방법과 마이크로서비스의 상호 작용 방법을 이해한다.
2. 소프트웨어 개발자: 코드를 작성하고 마이크로서비스를 제공하기 위해 프로그래밍 언어와 해당 언어용 개발 프레임워크의 사용 방법을 자세히 이해한다.
3. 데브옵스 엔지니어: 운영 환경 및 비운영 환경에서 서비스 배포와 관리 방법 정보를 제공한다. 모든 환경에서 일관성과 반복성을 제공해야 한다.

### 2.1 아키텍트 이야기: msa 설계

아키텍트는 해결해야 될 문제의 동작 모델을 제공해야 한다. 또 애플리케이션 코드가 서로 들어맞도록 개발자를 위한 발판도 제공해야 한다. 아키텍트는 다음 세 가지 일에 집중한다.

1. 비즈니스 문제의 분해: 아키텍트는 데이터 영역이 서로 어울리지 않는다면 마이크로서비스들의 서비스 경계를 나눈다. 비즈니스 문제를 인식하고 마이크로서비스 후보로 분해하는데 다음과 같은 지침이 있다.

   (1) 비즈니스 문제를 기술하고 그 문제를 기술하는 데 사용된 명사에 주목하라

   (2) 동사에 주목하라.

   (3) 데이터 응집성을 찾아라.

2. 서비스 세분화의 확정

   (1) 큰 마이크로서비스에서 시작해 작게 리팩토링하는 것이 더 낫다.

   (2) 서비스 간 교류하는 방식에 먼저 집중한다.

   (3) 문제 영역에 대한 이해가 깊어짐에 따라 서비스 책임도 계속 변한다.

   > **나쁜 마이크로서비스의 징후**
   >
   > 마이크로서비스가 너무 크게 나뉘어 있다면...
   >
   > 1. 책임이 너무 많은 서비스
   > 2. 많은 테이블의 데이터를 관리하는 서비스
   > 3. 과다한 테스트 케이스
   >
   > 마이크로서비스가 너무 잘게 나뉘어 있다면...
   >
   > 1. 한 문제 영역 부분에 속한 마이크로서비스가 토끼처럼 번식한다
   > 2. 마이크로서비스가 지나치게 상호 의존적이다
   > 3. 마이크로서비스가 단순한 CRUD 집합이 된다

3. 서비스 인터페이스의 정의: 서비스 인터페이스는 직관적이고 개발자가 1~2개의 애플리케이션 서비스를 학습하고 나면 애플리케이션의 모든 서비스에 대한 동작 규칙을 습득할 수 있어야 한다. 서비스 인터페이스 설계를 고려할 때 다음 지침을 사용할 수 있다.

   (1) REST 철학을 수용하라

   (2) URI를 사용해 의도를 전달하라

   (3) 요청과 응답에 JSON을 사용하라

   (4) HTTP 상태 코드로 결과를 전달하라

### 2.2 마이크로서비스를 사용하지 않아야 할 때

1. 분산 시스템 구축의 복잡성
2. 가상 서버/컨테이너의 스프롤: msa 기반 애플리케이션의 운영 환경에서 구축 및 관리가 필요한 서버나 커네이너가 50~100개 있을 수 있다. 클라우드에서 이들 서비스를 실행하는 데 드는 비용은 저렴하더라도 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡할 수 있다.
3. 애플리케이션 유형: 마이크로서비스는 재사용성을 추구하며 높은 회복성과 확장성이 필요한 대규모 애플리케이션의 구축에 유용하다. 그렇지 않은 애플리케이션에선 유용하지 않을 수 있다.
4. 데이터 변환과 일관성

### 2.3 데브옵스 이야기: 혹독한 런타임 구축

1. 마이크로서비스는 자체완비형이며 독립적으로 배포 가능해야 한다. - 서비스 어셈블리
2. 마이크로서비스는 구성 가능해야 한다. - 서비스 부트스트래핑
3. 마이크로서비스 인스턴스는 클라이언트가 위치를 알지 못하도록 투명해야 한다. - 서비스 등록 및 디스커버리
4. 마이크로서비스는 자신의 상태를 전달해야 한다. - 서비스 모니터링

#### 2.3.1 서비스 어셈블리: 마이크로서비스의 패키징과 배포

마이크로서비스는 필요한 의존성을 모두 담아 단일 산출물로 패키징하고 설치될 수 있어야 한다. 일관된 구축, 패키징 및 배포하는 이 과정을 서비스 어셈블리라고 한다.

애플리케이션 서버의 구성을 애플리케이션과 분리하므로 배포 과정에서 문제점이 발생하는데, 많은 조직에서 애플리케이션 서버의 구성을 소스 제어 저장소에 보관하지 않고 사용자 인터페이스와 자체 제작한 스크립트를 사용해 관리하는 것이 원인이다. 내장형 런타임 엔진을 포함한 단일 산출물로 배포하면 이러한 구성 편차 문제를 상당 부분 제거한다. 전체 산출물을 소스 제어하에 관리하므로 애플리케이션 팀이 애플리케이션 빌드와 배포 방법을 더 효과적으로 추론할 수 있다.

#### 2.3.2 서비스 부트스트래핑: 마이크로서비스의 구성 관리

서비스 부트스트래핑은 마이크로서비스가 처음 가동할 때 시작하며 애플리케이션 구성 정보를 로드한다. 

#### 2.3.3 서비스 등록과 디스커버리: 클라이언트가 마이크로서비스와 통신하는 방법

마이크로서비스는 위치 투명성을 가져야 한다. 모든 서비스에는 고유하고 비영구적인 IP 주소가 할당된다. '일시적' 서비스의 단점은 끊임없이 서비스의 시작과 종료를 반복하는 상황에서 일시적 서비스를 대량으로 수동 또는 직접 관리하면서 장애가 발생할 수 있다는 것이다.

마이크로서비스 인스턴스는 제 3자 에이전트에 스스로 등록해야 하는데 이 등록 과정을 서비스 디스커버리라고 한다.

#### 2.3.4 마이크로서비스의 상태 전달

서비스 디스커버리 에이전트는 서비스 상태를 모니터링한다. 인스턴스가 고장나면 상태 확인 로직은 그 인스턴스를 인스턴스 가용 풀에서 제거한다. 상태를 확인함으로써 마이크로서비스 인스턴스가 실행중인 서버의 상태 정보를 제공하며 모니터링을 강화할 수 있다.

## 3. 스프링 클라우드 컨피그 서버로 구성 관리

코드에 박힌 애플리케이션 구성 데이터는 구성을 변경할 때마다 애플리케이션을 재컴파일하거나 재배포해야 하므로 종종 문제가 된다. 이 문제를 피하기 위해 개발자는 애플리케이션 코드에서 구성 정보를 완전히 분리한다. 이것으로 컴파일 과정을 거치지 않고 구성은 쉽게 변경할 수 있게 되었지만, 애플리케이션과 함께 관리되고 배포되어야 하는 산출물이 추가되어 복잡해진다.

많은 개발자가 구성 정보를 저장하기 위해 저수준의 프로퍼티 파일(YAML, JSON, XML 등)로 전환할 것이다. 대개 이러한 프로퍼티 파일은 데이터베이스 및 미들웨어의 접속 정보와 애플리케이션 행동 양식을 정하는 메타데이터가 존재하는 서버에 둔다. 애플리케이션을 프로퍼티 파일로 분리하는 것은 쉬우며, 대부분의 개발자는 구성 파일을 소스 관리 시스템에 넣거나 애플리케이션 일부로 배포하는 일 외에는 애플리케이션 구성을 위한 어떤 운영 작업도 하지 않는다.

이러한 방식은 애플리케이션이 적은 상황에서는 적용될 수 있지만 수백 개의 마이크로서비스와 수많ㅇ느 마이크로서비스 인스턴스가 실행되는 클라우드 기반의 애플리케이션 상황에서는 전혀 통하지 않는다.

클라우드 기반 환경에 놓인 애플리케이션 팀과 운영 팀이 어떤 구성 파일을 어디에 배치할지 정하기 위해 대혼한을 겪어야 하므로 갑자기 구성 관리는 중대한 문제가 된다. 따라서 클라우드 기반의 마이크로서비스 개발에서는 다음 사항이 강조된다.

1. 배포라는 실제 코드에서 애플리케이션의 구성을 완전하게 분리한다.
2. 서버 및 애플리케이션을 빌드하고 배포 환경에 따라 절대 바뀌지 않는 불변 이미지를 빌드한다.
3. 서버를 시작할 때 환경 변수나 애플리케이션의 마이크로서비스가 읽어 올 수 있는 중앙 저장소를 이용해 애플리케이션 구성 정보를 주입한다.

### 3.1 구성 관리

항상 사람이 수동으로 구성하거나 배포하면 구성 편차와 예상하지 못한 장애, 애플리케이션 확장 요구에 대한 지체 시간이 발생할 수 있다. 다음 네 가지 원칙이 있다. 

1. 분리: 실제 물리적인 서비스의 배포와 서비스 구성 정보를 완전히 분리하고자 한다. 애플리케이션 구성 정보를 서비스 인스턴스와 함께 배포하면 안 된다. 그 대신 시작하는 서비스에 환경 변수로 전달하거나 중앙 저장소에서 읽어 와 구성 정보를 전달해야 한다.
2. 추상호: 서비스 인터페이스 뒷 단에 있는 구성 데이터의 접근 방식을 추상화한다. 서비스 저장소에 직접 액세스하는 코드를 작성하기(파일이나 JDBC를 사용해 데이터베이스에서 데이터를 읽기)보다 애플리케이션이 REST 기반의 JSON 서비스를 사용해 구성 데이터를 조회하게 만들어야 한다.
3. 중앙 집중화: 클라우드 기반의 애플리케이션에는 말 그대로 수백 개의 서비스가 존재할 수 있으므로 구성 정보를 보관하는 저장소 개수를 최소로 줄이는 것이 중요하다. 애플리케이션의 구성 정보를 가능한 소수 저장소에 집중화한다.
4. 견고성: 애플리케이션 구성 정보를 배포된 서비스와 완전히 분리하고 중앙 집중화하므로 어떤 솔루션을 사용하더라도 고가용성과 다중성을 구현할 수 있어야 한다.

핵심적으로 기억할 사항은 구성 정보를 실제 코드 외부로 분리하면 관리하고 버전 제어를 해야 할 외부 의존성이 생긴다는 것이다. 애플리케이션의 구성을 제대로 관리하지 못하면 탐지하기 어려운 버그와 예상하지 못한 장애를 만드므로 애플리케이션의 구성 데이터를 추적하고 버전을 제어하는 것은 중요하다.

#### 3.1.1 구성 관리 아키텍처

2장에서 배웠듯 구성 관리는 마이크로서비스의 부트스트래핑 단계(어셈블리, 부트스트래핑, 디스커버리, 모니터링 중)에서 일어난다. 

부트스트래핑 과정을 자세히 살펴보고, 구성 관리 서비스가 이 단계에서 어떻게 역할을 수행하는지 알아보자.

1. 마이크로서비스 인스턴스가 시작하고 (구성 서비스에서)구성 정보를 얻는다. : 마이크로서비스 인스턴스가 시작하면 서비스 엔드포인트를 호출해 동작 중인 환경별 구성 정보를 읽어 온다. 구성 관리 서비스에 연결할 정보(접속용 자격 증명, 서비스 엔드포인트 등)는 마이크로서비스가 시작할 때 전달된다.
2. 실제 구성 정보는 구성 서비스 저장소에 저장된다. : 구성 데이터를 보관할 수 있는 구성 저장소 구현 방식이 다양하며, 소스 관리되는 파일이나 관계형 데이터베이스, 키-값 짝 데이터 저장소 같은 구현 방식을 택할 수 있다.
3. 개발자가 구성 정보를 변경하면 빌드 및 배포 파이프라인으로 구성 저장소에 전달된다. : 실제로 애플리케이션 배포 방식과 독립적으로 애플리케이션의 구성 데이터를 관리한다. 대개 빌드 및 배포 파이프라인으로 구성 관리를 변경하며, 변경된 구성은 버전 정보 태그를 달아 다른 환경에 배포될 수 있게 한다.
4. 변경된 구성이 있는 애플리케이션은 갱신하도록 알림을 받는다. : 구성 관리가 변경되면 애플리케이션 구성 데이터를 사용하는 서비스는 변경 통보를 받고 보유한 애플리케이션 데이터 사본을 갱신해야 한다.

#### 3.1.2 구현 선택

구성 관리 시스템을 구현하는 오픈 소스 프로젝트

| 프로젝트 이름               | 설명                                                         | 특성                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 유레카                      | 넷플릭스가 만들었고 수많은 실전 테스트를 거쳤다. 서비스 검색과 키-값 관리에 사용된다. | - 분산 키-값 저장소 <br/>- 유연하지만 설정하는 데 공수가 든다.<br/> - 동적 클라이언트 갱신 기능을 제공한다. |
| 스프링 클라우드 컨피그 서버 | 다양한 백엔드와 함께 일반적인 구성 관리 솔루션을 제공하는 오픈 소스 프로젝트. 깃, 유레카 및 콘설 같은 백엔드와 통합 가능하다. | - 비분산 키-값 저장소<br/>- 스프링 및 스프링 기반이 아닌 서비스와 통합 가능하다.<br/>- 공유 파일과 시스템, 유레카, 콘설, 깃 등 구성 데이터 저장을 위한 다양한 백엔드 사용이 가능하다. |

이외에도 Etcd, 콘설, 주키퍼 등이 있다.

책에서 클라우드 컨피그 서버를 선택한 이유는

1. 스프링 클라우드 컨피그 서버는 쉽게 설치하고 사용할 수 있다.
2. 스프링 클라우드 컨피그는 스프링 부트와 긴밀히 통합되어 있다. 따라서 모든 애플리케이션의 구성 데이터를 사용이 간편한 애너테이션으로 읽어올 수 있다.
3. 스프링 클라우드 컨피그 서버는 구성 데이터를 저장할 수 있는 여러 백엔드를 지원한다. 유레카나 콘설 같은 도구를 이미 사용하고 있다면 바로 스프링 클라우드 컨피그 서버에 연결할 수 있다.
4. 깃 소스 제어 플랫폼과 직접 통합할 수 있다. 스프링 클라우드 컨피그를 깃과 통합하면 다른 솔루션으 ㅣ 추가 의존성을 제거하고 애플리케이션의 구성 데이터를 손쉽게 버전 관리할 수 있다. Etcd, 콘설, 유레카 같은 다른 도구는 자체 버전 관리 기능이 없으므로 필요하다면 직접 구축해야한다.



### 3.2 스프링 클라우드 컨피그 서버 구축

스프링 클라우드 컨피그 서버는 스프링 부트로 만든 REST 기반의 애플리케이션이다. 독립형 서버로 제공되지 않아 기존 스프링 부트 애플리케이션에 내장하거나 새로운 스프링 부트 프로젝트르 ㄹ 만들어 내장하는 방법으로 시작할 수 있다.

스프링 클라우드 컨피그에서 모든 것은 계층 구조로 동작한다. 애플리케이션 구성은 애플리케이션 이름을 먼저 표시하고 구성 정보가 필요한 각 환경별 프로퍼티 파일로 구분한다. 각 환경에 두 가지 구성 프로퍼티를 설정한다.

1. 라이선싱 서비스가 직접 사용할 예제 프로퍼티
2. 라이선싱 서비스의 데이터가 저장될 Postgres 데이터베이스를 위한 데이터베이스 구성

> 중대형 클라우드 애플리케이션에 파일 시스템 기반의 솔루션 사용을 권장하지 않는다. 파일 시스템 방식을 사용하는 것은 애플리케이션 구성 데이터를 액세스하려는 모든 구성 서버에 공유된 파일 마운트를 구현해야 한다는 것을 의미한다. 클라우드에 공유 파일 시스템 서버를 구축할 수 있지만 이 환경을 유지 보수해야 할 책임이 따른다.

하나의 서비스를 처음 시작할 때 명령줄로 두 가지 정보(스프링 프로파일과 스프링 클라우드 컨피그 서비스와 통신할 때 사용하는 엔드포인트)를 전달한다. 스프링 프로파일은 스프링 서비스가 추출하는 프로퍼티 환경에 매핑된다. 서비스가 처음 부팅하면 전달받은 프로파일과 엔드포인트를 사용해 스프링 클라우드 컨피그 서비스와 통신한다. 스프링 클라우드 컨피그 서비스는 URI로 전달된 특정 스프링 프로파일에 해당되는 구성 정보를 뒷 단의 구성 저장소(파일 시스템, 깃, 유레카 등)에서 조회한 후 적절한 프로퍼티 값을 라이선싱 서비스에 돌려준다. 스프레이 붙크 프레임워크는 이 프로퍼티 값을 애플리케이션에 적절히 삽입한다.

