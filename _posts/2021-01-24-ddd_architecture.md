---
layout: post
title:  DDD - 아키텍처
date:   2021-01-24 13:10:00 +0800
categories: DDD
tag: architecture
sitemap :
  changefreq : daily
  priority : 1.0
---

이 포스트는 IDDD 4장을 보고 작성합니다.

DDD의 장점 중 하나는 특정 아키텍처의 사용을 요구하지 않는다는 점이다. 

아키텍처 스타일과 패턴을 선택할 때는 유스케이스와 사용자 스토리, 도메인 모델의 시나리오 등과 같은 기능적 요구사항을 사용할 수 있는지를 고려해야한다. 즉 기능적 요구사항 없이는 필요한 소프트웨어 품질을 결정할 수 없다.

## 4 계층

사용자 인터페이스에서 찾을 수 있는 유효성 검사의 유형은 도메인 모델에 속해 있는 유형과는 다르다. 깊은 비즈니스 지식을 표현하는 대단위 유효성 검사는 모델로만 제한하는 편이 좋다.

사용자 인터페이스 컴포넌트가 도메인 모델의 객체를 사용하더라도 일반적으론 데이터를 투명한 유리에 올려두는 수준으로 제한된다. 

애플리케이션 계층에서는 도메인 로직이 전혀 없고, 영속성 트랜잭션과 보안을 제어할 수 있다. 또한 이벤트 기반의 알림을 다른 시스템으로 보내거나, 사용자에게 보낼 이메일 메시지의 작성을 담당할 수도 있다. 보통 애그리거트를 리포지토리에서 가져와서 몇몇 커맨드 오퍼레이션을 수행한다. 애플리케이션 서비스는 새로운 애그리게잇 인스턴스를 생성하고 리포지토리로 저장시킨다. 무상태 오퍼레이션으로 설계된 일부 도메인별 태스크를 완성하기 위해 도메인 서비스를 사용할 수도 있다.

애플리케이션 계층은 이벤트에 구독자를 등록할 수 있다. 이렇게 함으로써 이벤트를 저장하거나 전달하거나 애플리케이션이 책임지고 처리토록 할 수 있다. 이를 통해 도메인 모델이 고유한 핵심 문제만 알면 되는 자유로움을 갖고, 도메인 이벤트 게시자를 경량으로 유지할 수 있도록 해주며, 메시징 인프라스트럭처 의존성으로부터 해방된다.



## 헥사고날(육각형) 아키텍처

DI를 적용하면 실제론 계층이 나눠지지 않다고 할 수 있을지도...? 상,하위 모두 추상화에 의존하니 스택처럼 쌓여있던 레이어 형태가 무너지는듯 보인다! 

이 아키텍처에서는 다양한 이질적 클라이언트가 동등한 지위에서 시스템과 상호작용하도록 한다. 새로운 클라이언트가 필요하다고 해도 내부 애플리케이션의 API가 클라이언트의 입력을 이해하도록 변환해주는 어댑터만 추가해주면 된다. 이로써 시스템이 사용하는 그래픽, 영속성, 메시징 같은 출력 메커니즘이 다양해지고 쉽게 대체할 수 있게 된다. 애플리케이션 결과를 지정된 출력 메커니즘이 허용하는 형태로 변환하기 위해 어댑터를 생성했기 때문이다.

의존성 주입이 무조건 헥사고날을 의미하진 않는다. 아키텍처를 만드는 과정에서 자연스럽게 포트와 어댑터 스타일의 방향으로 흘러가게 해줄 뿐이다.

일반적으로 프론트 엔드(클라이언트가 시스템과 상호작용하는 곳), 백 엔드(애플리케이션이 저장된 영속성 데이터를 가져오거나 새로운 영속성 데이터를 저장하거나 출력을 내보내는 곳)로 나눈다. 그런데 헥사고날은 시스템을 다른 방식으로 바라본다.

여기엔 외부와 내부의 두 주요 영역이 있다. 외부 영역은 이질적 클라이언트가 입력을 보낼 수 있도록 해주고 영속 데이터를 가져오거나 애플리케이션 출력을 저장(db)하거나 다른 위치로 전송(메시징)하는 메커니즘을 제공한다. 

외부 타입마다 어댑터가 존재하고 외부 영역은 애플리케이션의 API를 통해 내부 영역과 이어진다.

각 헥사고날의 면은 입력이든 출력이든 각기 다른 종류의 포트를 표현한다. 예를 들어 하나의 포트는 HTTP를 사용하고 다른 하나는 AMQP를 사용할지도. 포트를 정의하는 엄격한 틀이 있는 것은 아니고 따라서 포트는 유연하게 해석된다. 포트를 어떻게 나눴든 클라이언트의 요청이 도착하면 그에 해당하는 각각의 어댑터가 이 입력을 변환해준다.

헥사고날을 사용하면 유스케이스를 염두에 두고 설계할 뿐이지, 지원되는 클라이언트의 수를 고려하진 않는다.